---
title: "TacMo"
author: "Julie Jung"
date: "July 14, 2018"
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r}
rm(list=ls()) #clear environment
setwd('/Users/juliejung/Documents/GitHub/TacMo') #set working directory       
```

# User Defined Functions

Here we'll define some functions that will help us later. The following function will give us the mode: 

```{r}
# gives mode
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

stderr <- function(vec) {
  return(sd(vec)/sqrt(length(vec)))
}
```

# Load packages

Here, we install and load packages that we'll need later on in the code. 
NOTE: uncomment as needed. 

```{r}
# install.packages("stargazer")
# install.packages("knitr")
# install.packages("dplyr")
# install.packages("curl")
# install.packages("sciplot")
# install.packages("ggplot2")
# install.packages("MASS")
#install.packages("multcomp")
# #install.packages("AICcmodavg", dependencies = TRUE)
# #install.packages("VGAM")
# install.packages("car")

library("stargazer")
library("knitr")
library("dplyr")
library("curl")
library("sciplot")
library("ggplot2")
library("MASS")
library("multcomp")
#library("VGAM") #not available for R version 3.3.3
#library("AICcmodavg") #not available for R version 3.3.3
library("lme4")
library("car")
library("xlsx")
```
# 2017 TacMo Data

Next, we want to read in the relevant datafile (from the data-reanalysis-assignment repo) and show a few lines of raw data in your output (e.g., using head()).

```{r}
data2017 <- read.csv(file="TacMo_2017_Jung20180714_clean.csv")
head(data2017)
```

Results, part I

Now that we've gone through all our preparations, we can run analyses and report replicated results! The following results follow the order of presented results in the paper (pdf in repo).  

First, we will check there are at least 5 eggs per tray. 

```{r}
min(data2017$Test.eggs.primary, na.rm=T) 
quantile(data2017$Test.eggs.primary, na.rm=T) 
mean(data2017$Test.eggs.primary, na.rm=T) 
se(data2017$Test.eggs.primary, na.rm=T) 
```

Now let's look at the structure of our data, and make sure the variables are defined as we want them to be defined. 

```{r, warning=FALSE}
str(data2017)
#data$ProportionHatched<-as.numeric(as.character(data$ProportionHatched))
#data$Date<-as.factor(data$Date)
```

Here let's subset the data into 2 age groups: younger and older. 

```{r, warning=FALSE}
younger2017<-subset(data2017, Age.day==4, na.rm=T)
older2017<-subset(data2017, Age.day==5, na.rm=T)
```

Since the paper reports the mode of stages for each age category, let's find that: 

```{r}
youngerstages2017<- rbind(younger2017$Stage1, younger2017$Stage2, younger2017$Stage3)
olderstages2017<- rbind(older2017$Stage1, older2017$Stage2, older2017$Stage3)

range(youngerstages2017, na.rm=T)
range(olderstages2017, na.rm=T)
Mode(youngerstages2017)
Mode(olderstages2017)

#Mode(younger2017$Stage.avg)
#Mode(older2017$Stage.avg)
```

> Younger embryos showed a range of stages from 20 to 31 while older embryos had 29 to 34 (N = 63 and 63; modes: 29 and 31).


## Proportion Hatched

Summarize the data

Here we'll create a table summary of statistics for hatching rates (in proportion hatched) for each age category, grouped by stimulus treatment. We use the {dplyr} package to summarize our data. 

```{r}
younger_errorstats2017<-
  younger2017 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(PH.primary),
            SD = sd(PH.primary), 
            SE = sd(PH.primary)/sqrt(n())
            )
younger_errorstats2017$AgeGroup <- 4
kable(younger_errorstats2017,title="Mean & SD & SE",digits=3)

older_errorstats2017<-
  older2017 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(PH.primary),
            SD = sd(PH.primary), 
            SE = sd(PH.primary)/sqrt(n())
            )
older_errorstats2017$AgeGroup <- 5
kable(older_errorstats2017,title="Mean & SD & SE",digits=3)
```

Should we use parametric or non-parametric tests?

```{r}
hist(data2017$Stage.avg) # non parametric probably?
plot(density(data2017$Stage.avg)) # non parametric yes
qqnorm(data2017$Stage.avg); qqline(data2017$Stage.avg, col = 2) # mhm non parametric definitely
shapiro.test(data2017$Stage.avg) # mhm non parametric definitely (<0.05)
```
The output of the shapiro-wilk test tells us that it's safe to reject the null hypothesis, which is that the distribution is normal.

We'll use mann-whitney-wilcoxon test because our 2 data samples (younger and older) are independent/come from distinct populations, so the samples do not affect each other. 

Also because our data are non-parametric. 

```{r, warning=FALSE}
wtest<-wilcox.test(data2017$Stage.avg~data2017$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```

CHANGE INFO BELOW (i copy pasted from another script)
> Younger embryos showed a range of stages from intact yolks to curved furrows while older embryos had straight furrows to full coils (N = 39 and 42; modes: straight furrow(1) and full coil(3); Wilcoxon test, Z=6.606223, P =1.97e-11). 


Embryos also hatched spontaneously between test ages, so we want to calculate some means and SEs for spontaneous hatching before the test period. 

```{r}
mean(younger2017$Already.H)
se(younger2017$Already.H)
mean(older2017$Already.H)
se(older2017$Already.H)
```

CHANGE THIS TEXT
> From trays tested, more of the older embryos had hatched spontaneously before the test period (0.9 ± 0.1 vs. 0.5 ± 0.1 embryos per tray). 

Since the data are non-parametric, we'll perform a mann-whitney test: 

```{r}
hist(log(data2017$Already.H)) #non-parametric, even when log transformed --> use a mann-whitney
wtest<-wilcox.test(data2017$Already.H~data2017$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```

CHANGE THIS TEXT
> From trays tested, more of the older embryos had hatched spontaneously before the test period (0.9 ± 0.1 vs. 0.5 ± 0.1 embryos per tray; Wilcoxon test, Z=2.439, P = 0.0074) and relatively fewer of the trays with older eggs had sufficient individuals to attempt setup (KMW unquantified personal observation). 


Now we'll look at the number of embryos that hatched at set up: 

```{r}
mean(younger2017$H.in.setup)
se(younger2017$H.in.setup)
mean(older2017$H.in.setup)
se(older2017$H.in.setup)
```
CHANGE THIS TEXT
> More of the older embryos hatched during setup and acclimation (2.5 ± 0.3 vs. 0.9 ± 0.2 per tray). 

Since the data are non-parametric, we'll perform a mann-whitney test: 

```{r}
hist(data2017$H.in.setup)#non-parametric, mann-whitney
wtest<-wilcox.test(data2017$H.in.setup~data2017$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```

CHANGE THIS TEXT
> More of the older embryos hatched during setup and acclimation (2.5 ± 0.3 vs. 0.9 ± 0.2 per tray; Wilcoxon test, Z=404.5, P = 5.085e-5). 

We want to calculate some means and ses for the number of test eggs per tray in older vs. younger. 

```{r}
#smaller number of test eggs per tray in older than younger
mean(younger2017$Test.eggs.primary)
se(younger2017$Test.eggs.primary)
mean(older2017$Test.eggs.primary)
se(older2017$Test.eggs.primary)

# min(younger2017$Test.eggs.primary)
# max(younger2017$Test.eggs.primary)
# min(older2017$Test.eggs.primary)
# max(older2017$Test.eggs.primary)
```
CHANGE THIS TEXT
> This resulted in smaller numbers of test eggs per tray (older 11.5 ± 0.3, younger 13.5 ± 0.2, range 8–15 at both ages). 

Since the data are non-parametric, we'll perform a mann-whitney test: 

```{r}
hist(data2017$Test.eggs.primary)#non-parametric, mann-whitney
wtest<-wilcox.test(data2017$Test.eggs.primary~data2017$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```
CHANGE THIS TEXT ACCORDINGLY
> This resulted in smaller numbers of test eggs per tray (Wilcoxon test, Z=4.361872, P =6.448e-6; older 11.5 ± 0.3, younger 13.5 ± 0.2, range 8–15 at both ages). 

Results, part II: Visualizations

Next, we want to know whether age, stimulus, and/or their interaction affected the hatching response of embryos in playbacks 

We'll do this by performing a binomial GLMM: 
```{r}
glmm0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1 + (1|Clutch), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glm4<-glm(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus, family=binomial(logit), data=data2017)
glmm1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+ (1|Clutch), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm2<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+ (1|Clutch), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm3<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+Stimulus+ (1|Clutch), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm4<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Clutch), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa")) ###
glmm5<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm6<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Date)+(1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))###########
glmm7<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Age.day/Clutch), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))

# bb1<-betabin(cbind(Hatch.primary,Test.eggs.primary)~Stimulus, ~1, data=hatching_data)

#To avoid a warning of nonconvergence, we specify a different optimizer with the argument control=glmerControl(optimizer="bobyqa"). Although the model will produce nearly identical results without the new argument, we prefer to use models without such warnings.
AIC(glm4)
AIC(glmm1)
AIC(glmm2)
AIC(glmm3)
AIC(glmm4)
AIC(glmm5)
AIC(glmm6) ###*
AIC(glmm7)

#how that we know what basic model to use, rename the models using the right random effects - for max likelihood approach. 

glmm0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1 +(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm2<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm3<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm4<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus +(1|Date), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm5<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))
glmm6<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus +(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2017, control=glmerControl(optimizer="bobyqa"))###########

anova(glmm0,glmm1) #Age effect 
anova(glmm0,glmm2) #Stimulus effect 
# anova(glmm1,glmm3) #Stimulus effect - again
# anova(glmm2,glmm3) #Age effect - again
anova(glmm3,glmm6) #interaction effect 
# anova(glmm4,glmm6) # clutch/tray random effect
# anova(glmm5,glmm6) # date random effect

# Anova(glmm6) #Age   - Stim   - Interaction
```

> Age, stimulus, and their interaction affected the hatching response of embryos in playbacks (Fig. 6A). Older embryos hatched more than did younger ones (binomial GLMM with clutch as a random effect, age effect: χ2 = 58.661, df = 1, P=1.873e-14), and the LF stimulus elicited the strongest hatching response (stimulus effect: χ2 = 58.648, df = 2, P=1.839e-13). However, the significant age × stimulus interaction revealed that the developmental increase in hatching was not uniform across stimuli (interaction effect: χ2 = 12.362, df = 2, P = 0.002069). 

This is the plot for our proportion hatched data (Figure 6 in paper)

We can use ggplot to create a much pretty plot, with standard errors. 

```{r}
younger_errorstats2017$AgeGroup<-as.factor(younger_errorstats2017$AgeGroup)
older_errorstats2017$AgeGroup<-as.factor(older_errorstats2017$AgeGroup)
combined_errorstats2017<- rbind(younger_errorstats2017, older_errorstats2017)
```

The following code creates our figure:
```{r}
ggplot(data=combined_errorstats2017, aes(x=AgeGroup, y=mean, colour=Stimulus)) + 
  geom_point(size=3) +
  geom_errorbar(data=combined_errorstats2017, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  cowplot::theme_cowplot() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  scale_y_continuous(limits = c(0, 1)) +
  ylab("Proportion of tray hatched\n")+
  xlab("\n Age (d)")

```

Moving on: Here we perform separate binomial GLMs at each age, with grouped categories of treatment stimuli. 

```{r}
#binomial glm for YOUNGER
temp0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=younger2017, control=glmerControl(optimizer="bobyqa"))
temp1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=younger2017, control=glmerControl(optimizer="bobyqa"))
anova(temp0,temp1) #stimulus effect

#binomial glm for OLDER
temp0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=older2017, control=glmerControl(optimizer="bobyqa"))
temp1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=older2017, control=glmerControl(optimizer="bobyqa"))
anova(temp0,temp1) #stimulus effect

```
> Younger embryos showed equally little response to both the HF and LS stimuli but a substantial hatching response to the LF stimulus (Fig. 6A, stimulus effect: χ2 = 57.57, df = 2, P < 0.0001; HF–LS contrast χ2  = 1.48, P = 0.22; (HF+LS)–LF contrast χ2 = 370 56.75, P < 0.0001). In contrast, older embryos showed similarly strong hatching responses to both LF and LS stimuli and a weaker response to the HF stimulus (stimulus effect: χ2 = 73.84, df = 2, P < 0.0001; LF–LS contrast χ2 = 2.46, P = 0.12; (LF+LS)–HF contrast χ2 = 71.61, P < 0.0001). 

Here we want to see which stim are different from which others WITHIN younger and older treatments

```{r}
hist(log(younger2017$PH.primary))
hist(older2017$PH.primary)
hist(data2017$PH.primary)
```

Here let's subset the data into 5 categories: 
1. Motion only - all motion only
2. Tactile - contact (primary)
3. Tactile - NC (should be low hatching)
4. Motion & Tactile - contact (primary)
5. Motion & Tactile - NC (should be same as M-only)

```{r, warning=FALSE}
Mo_young<-subset(younger2017, Stimulus=="M-only", na.rm=T)
Tac_young<-subset(younger2017, Stimulus=="T-only", na.rm=T)
TacMo_young<-subset(younger2017, Stimulus=="M+T", na.rm=T)

Mo_old<-subset(older2017, Stimulus=="M-only", na.rm=T)
Tac_old<-subset(older2017, Stimulus=="T-only", na.rm=T)
TacMo_old<-subset(older2017, Stimulus=="M+T", na.rm=T)
```

YOUNGER COMPARISONS: Non parametric so i should use the wilcoxon rank sums test
```{r}
wtest<-wilcox.test(as.numeric(Mo_young$PH.primary), as.numeric(Tac_young$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Mo_young$PH.primary), as.numeric(TacMo_young$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Tac_young$PH.primary), as.numeric(TacMo_young$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest
```

OLDER COMPARISONS: Non parametric so i should use the wilcoxon rank sums test
```{r}
wtest<-wilcox.test(as.numeric(Mo_old$PH.primary), as.numeric(Tac_old$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Mo_old$PH.primary), as.numeric(TacMo_old$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Tac_old$PH.primary), as.numeric(TacMo_old$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest
```

## Latency to Hatch

Because risk in predator attacks probably accrues as a function of time, 
but information from temporal properties accrues as a function of cycles 
we conducted analyses of latency measured both in time (seconds) 
and in cycles (dividing time by the cycle length of the stimulus). 

```{r}
min(data2017$Con1, na.rm=T)
max(data2017$Con1, na.rm=T)
```
> In trays where hatching occurred, the latency until the first embryo hatched ranged from 9–420 s. 

Are our data parametric?

```{r}
hist(data2017$Con1) #nonparametric
hist(log(data2017$Con1)) #parametric!
```
Since they are, we can use ANOVAs of log-transformed data to test for 
effects of age, stimulus and age-by-stimulus interaction 
on the latency to hatch. 

```{r}
# IN SECONDS, Anova
aov1 <- aov(log(Con1) ~ Age.day*Stimulus, data=data2017)
summary(aov1)
```
> Latency varied among stimuli and decreased with age, with a marginally non-significant interaction effect (Fig. 6B,C). This pattern held whether measuring latency in seconds or in cycles of vibration (seconds: age, F1,58 = 39.52, P < 0.0001; stimulus, F2,58 = 13.72, P < 0.0001; interaction, F2,58 = 2.91, P = 0.0625; cycles: age, F1,58 = 49.54, P < 0.0001; stimulus, F2,58 = 71.89, P < 0.0001; interaction, F2,58 = 2.91, P = 0.0625).

Alternatively, we can use GLMs: 

```{r}
# # IN SECONDS, GLM METHOD
# glmm1<-glmer(Con1~Age.day+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)
# glmm2<-glmer(Con1~Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)
# glmm3<-glmer(Con1~Age.day+Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)
# glmm4<-glmer(Con1~Age.day*Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)
# 
# aic(glmm1)
# aic(glmm2)
# aic(glmm3)
# aic(glmm4)
# 
# Anova(glmm4)
```

Here we plot the latencies for the first embryo in each tray to hatch: 

```{r}
str(younger2017)

LtoH_younger_errorstats2017<-
  younger2017 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(Con1, na.rm=T),
            SD = sd(Con1, na.rm=T), 
            SE = sd(Con1, na.rm=T)/sqrt(n())
            )
LtoH_younger_errorstats2017$AgeGroup <- "4"
kable(LtoH_younger_errorstats2017,title="Mean & SD & SE",digits=3)

LtoH_older_errorstats2017<-
  older2017 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(Con1, na.rm=T),
            SD = sd(Con1, na.rm=T), 
            SE = sd(Con1, na.rm=T)/sqrt(n())
            )
LtoH_older_errorstats2017$AgeGroup <- "5"
kable(LtoH_older_errorstats2017,title="Mean & SD & SE",digits=3)
```

Now we can make the plot! 

```{r}
LtoH_combined_errorstats2017<- rbind(LtoH_younger_errorstats2017, LtoH_older_errorstats2017)
```

The following code creates our figure:
```{r}
ggplot(data=LtoH_combined_errorstats2017, aes(x=AgeGroup, y=mean, colour=Stimulus)) + 
  geom_point(size=3) +
  geom_errorbar(data=LtoH_combined_errorstats2017, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  theme_bw(20)+
  ylab("Latency to hatch (seconds)\n")+
  xlab("\n Age (d)")
```



```{r}
str(data2017)
MotionOnly<-subset(data2017, Stimulus=="M-only", na.rm=T)
TactileOnly<-subset(data2017, Stimulus=="T-only", na.rm=T)
MotionTactile<-subset(data2017, Stimulus=="M+T", na.rm=T)

motion_younger<-subset(MotionOnly, Age.day==4, na.rm=T)
motion_older<-subset(MotionOnly, Age.day==5, na.rm=T)
tactile_younger<-subset(TactileOnly, Age.day==4, na.rm=T)
tactile_older<-subset(TactileOnly, Age.day==5, na.rm=T)
mt_younger<-subset(MotionTactile, Age.day=4, na.rm=T)
mt_older<-subset(MotionTactile, Age.day==5, na.rm=T)

mean(mt_older$Con1, na.rm=T)
se(mt_older$Con1, na.rm=T)

```
> The shortest latency times were for the LF stimulus (younger: 39.5 ± 10.1 s; older 18.6 ± 1.9 s), 
 while latencies for the LS stimulus included the fewest cycles of the vibration pattern 
(younger: 6.5 ± 1.6; older: 1.9 ± 0.3 cycles). 


We conducted analyses of latency both on the subset of trays from which at least one individual hatched and also on the full dataset, assigning a latency of 600 s (i.e., the full playback plus post-playback observation period) to trays in which no embryos hatched.

```{r}

# IN SECONDS, Anova
aov1 <- aov(Con1_600 ~ Age.day*Stimulus, data=data2017) ##create this column
summary(aov1)

# IN SECONDS, GLM METHOD
glmm1<-glmer(Con1_600~Age.day+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)
glmm2<-glmer(Con1_600~Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)
glmm3<-glmer(Con1_600~Age.day+Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)
glmm4<-glmer(Con1_600~Age.day*Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2017)

glmms<-list(glmm1, glmm2, glmm3, glmm4)
#aictab(glms)

Anova(glmm4)
```

> If we assign a latency of 600 s to trays in which no embryos hatched, age and stimulus effects remain strong and the interaction effect is much weaker (latency in seconds: age, F1,75 = 27.98, P < 0.0001; stimulus, F2,75 = 7.77, P = 0.0009; interaction F2,75 = 0.75, P = 0.47). 

# 2018 TacMo Data

Next, we want to read in the relevant datafile and show a few lines of raw data in your output (e.g., using head()).

```{r}
#f <- curl("https://raw.githubusercontent.com/jamjulie/data-reanalysis-assignment/master/WarkentinJungRuedaMcDaniel-DataForDeposit.csv")
#data <- read.csv(f, header = TRUE, sep = ",", stringsAsFactors = TRUE)
data2018 <- read.csv(file="TacMo_2018_Jung20180826_clean.csv")
head(data2018)
```

Results, part I

Now that we've gone through all our preparations, we can run analyses and report replicated results! The following results follow the order of presented results in the paper (pdf in repo).  

First, we will check there are at least 5 eggs per tray. 

```{r}
min(data2018$Test.eggs.primary, na.rm=T) 
quantile(data2018$Test.eggs.primary, na.rm=T) 
mean(data2018$Test.eggs.primary, na.rm=T) 
se(data2018$Test.eggs.primary, na.rm=T) 
```

Now let's look at the structure of our data, and make sure the variables are defined as we want them to be defined. 

```{r, warning=FALSE}
str(data2018)
#data$ProportionHatched<-as.numeric(as.character(data$ProportionHatched))
#data$Date<-as.factor(data$Date)
```

Here let's subset the data into 2 age groups: younger and older. 

```{r, warning=FALSE}
younger2018<-subset(data2018, Age.day==4, na.rm=T)
older2018<-subset(data2018, Age.day==5, na.rm=T)
```

Since the paper reports the mode of stages for each age category, let's find that: 

```{r}
youngerstages2018<- rbind(younger2018$Stage1, younger2018$Stage2, younger2018$Stage3)
olderstages2018<- rbind(older2018$Stage1, older2018$Stage2, older2018$Stage3)
range(youngerstages2018)
range(olderstages2018)
Mode(youngerstages2018)
Mode(olderstages2018)

#Mode(younger2018$Stage.avg)
#Mode(older2018$Stage.avg)
```

> Younger embryos showed a range of stages from 20 to 31 while older embryos had 29 to 34 (N = 63 and 63; modes: 29 and 31).


## Proportion Hatched
Summarize the data

Here we'll create a table summary of statistics for hatching rates (in proportion hatched) for each age category, grouped by stimulus treatment. We use the {dplyr} package to summarize our data. 

```{r}
younger_errorstats2018<-
  younger2018 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(PH.primary),
            SD = sd(PH.primary), 
            SE = sd(PH.primary)/sqrt(n())
            )
younger_errorstats2018$AgeGroup <- 4
kable(younger_errorstats2018,title="Mean & SD & SE",digits=3)

older_errorstats2018<-
  older2018 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(PH.primary),
            SD = sd(PH.primary), 
            SE = sd(PH.primary)/sqrt(n())
            )
older_errorstats2018$AgeGroup <- 5
kable(older_errorstats2018,title="Mean & SD & SE",digits=3)
```

### Within stimulus categories

Here let's subset the data into 5 categories: 
1. Motion only - all motion only
2. Tactile - contact (primary)
3. Tactile - NC (should be low hatching)
4. Motion & Tactile - contact (primary)
5. Motion & Tactile - NC (should be same as M-only)

```{r, warning=FALSE}
Mo_young<-subset(younger2018, Stimulus=="M-only", na.rm=T)
Tac_young<-subset(younger2018, Stimulus=="T-only", na.rm=T)
TacMo_young<-subset(younger2018, Stimulus=="M+T", na.rm=T)

Mo_old<-subset(older2018, Stimulus=="M-only", na.rm=T)
Tac_old<-subset(older2018, Stimulus=="T-only", na.rm=T)
TacMo_old<-subset(older2018, Stimulus=="M+T", na.rm=T)
```

Should we use parametric or non-parametric tests?

```{r}
hist(data2018$Stage.avg) # non parametric probably?
plot(density(data2018$Stage.avg)) # non parametric yes
qqnorm(data2018$Stage.avg); qqline(data2018$Stage.avg, col = 2) # mhm non parametric definitely
shapiro.test(data2018$Stage.avg) # mhm non parametric definitely (<0.05)
```
The output of the shapiro-wilk test tells us that it's safe to reject the null hypothesis, which is that the distribution is normal.

We'll use mann-whitney-wilcoxon test because our 2 data samples (younger and older) are independent/come from distinct populations, so the samples do not affect each other. 

Also because our data are non-parametric. 

```{r, warning=FALSE}
wtest<-wilcox.test(data2018$Stage.avg~data2018$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```

CHANGE INFO BELOW (i copy pasted from another script)
> Younger embryos showed a range of stages from intact yolks to curved furrows while older embryos had straight furrows to full coils (N = 39 and 42; modes: straight furrow(1) and full coil(3); Wilcoxon test, Z=6.606223, P =1.97e-11). 


Embryos also hatched spontaneously between test ages, so we want to calculate some means and SEs for spontaneous hatching before the test period. 

```{r}
mean(younger2018$Already.H)
se(younger2018$Already.H)
mean(older2018$Already.H)
se(older2018$Already.H)
```

CHANGE THIS TEXT
> From trays tested, more of the older embryos had hatched spontaneously before the test period (0.9 ± 0.1 vs. 0.5 ± 0.1 embryos per tray). 

Since the data are non-parametric, we'll perform a mann-whitney test: 

```{r}
hist(log(data2018$Already.H)) #non-parametric, even when log transformed --> use a mann-whitney
wtest<-wilcox.test(data2018$Already.H~data2018$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```

CHANGE THIS TEXT
> From trays tested, more of the older embryos had hatched spontaneously before the test period (0.9 ± 0.1 vs. 0.5 ± 0.1 embryos per tray; Wilcoxon test, Z=2.439, P = 0.0074) and relatively fewer of the trays with older eggs had sufficient individuals to attempt setup (KMW unquantified personal observation). 


Now we'll look at the number of embryos that hatched at set up: 

```{r}
mean(younger2018$H.in.setup)
se(younger2018$H.in.setup)
mean(older2018$H.in.setup)
se(older2018$H.in.setup)
```
CHANGE THIS TEXT
> More of the older embryos hatched during setup and acclimation (2.5 ± 0.3 vs. 0.9 ± 0.2 per tray). 

Since the data are non-parametric, we'll perform a mann-whitney test: 

```{r}
hist(data2018$H.in.setup)#non-parametric, mann-whitney
wtest<-wilcox.test(data2018$H.in.setup~data2018$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```

CHANGE THIS TEXT
> More of the older embryos hatched during setup and acclimation (2.5 ± 0.3 vs. 0.9 ± 0.2 per tray; Wilcoxon test, Z=404.5, P = 5.085e-5). 

We want to calculate some means and ses for the number of test eggs per tray in older vs. younger. 

```{r}
#smaller number of test eggs per tray in older than younger
mean(younger2018$Test.eggs.primary)
se(younger2018$Test.eggs.primary)
mean(older2018$Test.eggs.primary)
se(older2018$Test.eggs.primary)

min(younger2018$Test.eggs.primary)
max(younger2018$Test.eggs.primary)
min(older2018$Test.eggs.primary)
max(older2018$Test.eggs.primary)
```
CHANGE THIS TEXT
> This resulted in smaller numbers of test eggs per tray (older 11.5 ± 0.3, younger 13.5 ± 0.2, range 8–15 at both ages). 

Since the data are non-parametric, we'll perform a mann-whitney test: 

```{r}
hist(data2018$Test.eggs.primary)#non-parametric, mann-whitney
wtest<-wilcox.test(data2018$Test.eggs.primary~data2018$Age.day, mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.95)
qnorm(wtest$p.value) #z-value to report
wtest
```
CHANGE THIS TEXT ACCORDINGLY
> This resulted in smaller numbers of test eggs per tray (Wilcoxon test, Z=4.361872, P =6.448e-6; older 11.5 ± 0.3, younger 13.5 ± 0.2, range 8–15 at both ages). 

Results, part II: Visualizations

Next, we want to know whether age, stimulus, and/or their interaction affected the hatching response of embryos in playbacks 

We'll do this by performing a binomial GLMM: 
```{r}
glmm0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1 + (1|Clutch), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glm4<-glm(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus, family=binomial(logit), data=data2018)
glmm1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+ (1|Clutch), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm2<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+ (1|Clutch), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm3<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+Stimulus+ (1|Clutch), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm4<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Clutch), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa")) ###
glmm5<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm6<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Date)+(1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))###########
glmm7<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Age.day/Clutch), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))

# bb1<-betabin(cbind(Hatch.primary,Test.eggs.primary)~Stimulus, ~1, data=hatching_data)

#To avoid a warning of nonconvergence, we specify a different optimizer with the argument control=glmerControl(optimizer="bobyqa"). Although the model will produce nearly identical results without the new argument, we prefer to use models without such warnings.
AIC(glm4)
AIC(glmm1)
AIC(glmm2)
AIC(glmm3)
AIC(glmm4)
AIC(glmm5)
AIC(glmm6) ###*
AIC(glmm7)

glmm0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1 +(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm2<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm3<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day+Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm4<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus +(1|Date), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm5<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus+ (1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))
glmm6<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Age.day*Stimulus +(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=data2018, control=glmerControl(optimizer="bobyqa"))###########

anova(glmm0,glmm1) #Age effect - 1.151e-11 ***
anova(glmm0,glmm2) #Stimulus effect - 0.0002467 ***
#anova(glmm1,glmm3) #Stimulus effect - 4.521e-05 ***
#anova(glmm2,glmm3) #Age effect - 2.038e-12 ***
anova(glmm3,glmm6) #interaction effect - 0.0001138 ***
anova(glmm4,glmm6) # clutch/tray random effect - 0.9786
anova(glmm5,glmm6) # date random effect - 0.00435 **

Anova(glmm6) #Age: 8.16e-14 ***   - Stim: 9.43e-05 ***    - Interaction: 0.0001156 ***
```

> Age, stimulus, and their interaction affected the hatching response of embryos in playbacks (Fig. 6A). Older embryos hatched more than did younger ones (binomial GLMM with clutch as a random effect, age effect: χ2 = 58.661, df = 1, P=1.873e-14), and the LF stimulus elicited the strongest hatching response (stimulus effect: χ2 = 58.648, df = 2, P=1.839e-13). However, the significant age × stimulus interaction revealed that the developmental increase in hatching was not uniform across stimuli (interaction effect: χ2 = 12.362, df = 2, P = 0.002069). 

This is the plot for our proportion hatched data (Figure 6 in paper)

```{r}
interaction.plot(data2018$Age.day, data2018$Stimulus, data2018$PH.primary, 
                 leg.bty="0", pch=c(18,24), 
                 ylab="Proportion hatched", 
                 xlab="Age (days)", 
                 trace.label="")
```

ALTERNATIVELY, we can use ggplot to create a much prettier plot, with standard errors. 

```{r}
younger_errorstats2018$AgeGroup<-as.factor(younger_errorstats2018$AgeGroup)
older_errorstats2018$AgeGroup<-as.factor(older_errorstats2018$AgeGroup)
combined_errorstats2018<- rbind(younger_errorstats2018, older_errorstats2018)
```

The following code creates our figure:
```{r}
ggplot(data=combined_errorstats2018, aes(x=AgeGroup, y=mean, colour=Stimulus)) + 
  geom_point(size=3) +
  geom_errorbar(data=combined_errorstats2018, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  cowplot::theme_cowplot() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  scale_y_continuous(limits = c(0, 1)) +
  ylab("Proportion of tray hatched\n")+
  xlab("\n Age (d)")

```

Moving on: Here we perform separate binomial GLMs at each age, with grouped categories of treatment stimuli. 

```{r}

#binomial glm for YOUNGER
temp0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=younger2018, control=glmerControl(optimizer="bobyqa"))
temp1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=younger2018, control=glmerControl(optimizer="bobyqa"))
anova(temp0,temp1) #stimulus effect

#binomial glm for OLDER
temp0<-glmer(cbind(Hatch.primary,Test.eggs.primary)~1+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=older2018, control=glmerControl(optimizer="bobyqa"))
temp1<-glmer(cbind(Hatch.primary,Test.eggs.primary)~Stimulus+(1|Date) +(1|Clutch/Tray), family=binomial(logit), data=older2018, control=glmerControl(optimizer="bobyqa"))
anova(temp0,temp1) #stimulus effect

```
> Younger embryos showed equally little response to both the HF and LS stimuli but a substantial hatching response to the LF stimulus (Fig. 6A, stimulus effect: χ2 = 57.57, df = 2, P < 0.0001; HF–LS contrast χ2  = 1.48, P = 0.22; (HF+LS)–LF contrast χ2 = 370 56.75, P < 0.0001). In contrast, older embryos showed similarly strong hatching responses to both LF and LS stimuli and a weaker response to the HF stimulus (stimulus effect: χ2 = 73.84, df = 2, P < 0.0001; LF–LS contrast χ2 = 2.46, P = 0.12; (LF+LS)–HF contrast χ2 = 71.61, P < 0.0001). 

Here we want to see which stim are different from which others WITHIN younger and older treatments

```{r}
hist(log(younger2018$PH.primary))
hist(older2018$PH.primary)
hist(data2018$PH.primary)
```

Here let's subset the data into 5 categories: 
1. Motion only - all motion only
2. Tactile - contact (primary)
3. Tactile - NC (should be low hatching)
4. Motion & Tactile - contact (primary)
5. Motion & Tactile - NC (should be same as M-only)

```{r, warning=FALSE}
Mo_young<-subset(younger2018, Stimulus=="M-only", na.rm=T)
Tac_young<-subset(younger2018, Stimulus=="T-only", na.rm=T)
TacMo_young<-subset(younger2018, Stimulus=="M+T", na.rm=T)

Mo_old<-subset(older2018, Stimulus=="M-only", na.rm=T)
Tac_old<-subset(older2018, Stimulus=="T-only", na.rm=T)
TacMo_old<-subset(older2018, Stimulus=="M+T", na.rm=T)
```

YOUNGER COMPARISONS: Non parametric so i should use the wilcoxon rank sums test
```{r}
wtest<-wilcox.test(as.numeric(Mo_young$PH.primary), as.numeric(Tac_young$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Mo_young$PH.primary), as.numeric(TacMo_young$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Tac_young$PH.primary), as.numeric(TacMo_young$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest
```

OLDER COMPARISONS: Non parametric so i should use the wilcoxon rank sums test
```{r}
wtest<-wilcox.test(as.numeric(Mo_old$PH.primary), as.numeric(Tac_old$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Mo_old$PH.primary), as.numeric(TacMo_old$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest

wtest<-wilcox.test(as.numeric(Tac_old$PH.primary), as.numeric(TacMo_old$PH.primary), mu = 0, alt="two.sided", paired = F, conf.int=T, conf.level=0.99)
qnorm(wtest$p.value) #z-value to report
wtest
```


## Latency to Hatch

```{r}
min(data2018$Con1, na.rm=T)
max(data2018$Con1, na.rm=T)
```
> In trays where hatching occurred, the latency until the first embryo hatched ranged from 5–506 s. 

Are our data parametric?

```{r}
hist(data2018$Con1) #nonparametric
hist(log(data2018$Con1)) #parametric!
```
Since they are, we can use ANOVAs of log-transformed data to test for 
effects of age, stimulus and age-by-stimulus interaction 
on the latency to hatch. 

```{r}
# IN SECONDS, Anova
aov1 <- aov(log(Con1) ~ Age.day*Stimulus, data=data2018)
summary(aov1)
```
> Latency varied among stimuli and decreased with age, with a marginally non-significant interaction effect (Fig. 6B,C). This pattern held whether measuring latency in seconds or in cycles of vibration (seconds: age, F1,58 = 39.52, P < 0.0001; stimulus, F2,58 = 13.72, P < 0.0001; interaction, F2,58 = 2.91, P = 0.0625; cycles: age, F1,58 = 49.54, P < 0.0001; stimulus, F2,58 = 71.89, P < 0.0001; interaction, F2,58 = 2.91, P = 0.0625).

Alternatively, we can use GLMs: 

```{r}
# IN SECONDS, GLM METHOD
glmm1<-glmer(Con1~Age.day+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm2<-glmer(Con1~Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm3<-glmer(Con1~Age.day+Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm4<-glmer(Con1~Age.day*Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)

glmms<-list(glmm1, glmm2, glmm3, glmm4)
#aictab(glms)

Anova(glmm4)
```

Here we plot the latencies for the first embryo in each tray to hatch: 

Subset the latency data - only the ones where at least one hatched
```{r}
younger2018_lats<- younger2018[is.na(younger2018$Con1),]
older2018_lats<- older2018[is.na(older2018$Con1),]
```

```{r}
LtoH_younger_errorstats2018<-
  younger2018_lats %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(Con1, na.rm=T),
            SD = sd(Con1, na.rm=T), 
            SE = sd(Con1, na.rm=T)/sqrt(n())
            )
LtoH_younger_errorstats2018$AgeGroup <- "4"
kable(LtoH_younger_errorstats2018,title="Mean & SD & SE",digits=3)

LtoH_older_errorstats2018<-
  older2018_lats %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(Con1, na.rm=T),
            SD = sd(Con1, na.rm=T), 
            SE = sd(Con1, na.rm=T)/sqrt(n())
            )
LtoH_older_errorstats2018$AgeGroup <- "5"
kable(LtoH_older_errorstats2018,title="Mean & SD & SE",digits=3)
```

Now we can make the plot! 

```{r}
LtoH_combined_errorstats2018<- rbind(LtoH_younger_errorstats2018, LtoH_older_errorstats2018)
```

The following code creates our figure:
```{r}
ggplot(data=LtoH_combined_errorstats2018, aes(x=AgeGroup, y=mean, colour=Stimulus)) + 
  geom_point(size=3) +
  geom_errorbar(data=LtoH_combined_errorstats2018, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  theme_bw(20)+
  ylab("Latency to hatch (seconds)\n")+
  xlab("\n Age (d)")
```



```{r}
str(data2018)
MotionOnly<-subset(data2018, Stimulus=="M-only", na.rm=T)
TactileOnly<-subset(data2018, Stimulus=="T-only", na.rm=T)
MotionTactile<-subset(data2018, Stimulus=="M+T", na.rm=T)

motion_younger<-subset(MotionOnly, Age.day==4, na.rm=T)
motion_older<-subset(MotionOnly, Age.day==5, na.rm=T)
tactile_younger<-subset(TactileOnly, Age.day==4, na.rm=T)
tactile_older<-subset(TactileOnly, Age.day==5, na.rm=T)
mt_younger<-subset(MotionTactile, Age.day=4, na.rm=T)
mt_older<-subset(MotionTactile, Age.day==5, na.rm=T)

mean(mt_older$Con1, na.rm=T)
se(mt_older$Con1, na.rm=T)

```
> The shortest latency times were for the LF stimulus (younger: 39.5 ± 10.1 s; older 18.6 ± 1.9 s), 
 while latencies for the LS stimulus included the fewest cycles of the vibration pattern 
(younger: 6.5 ± 1.6; older: 1.9 ± 0.3 cycles). 


We conducted analyses of latency both on the subset of trays from which at least one individual hatched and also on the full dataset, assigning a latency of 600 s (i.e., the full playback plus post-playback observation period) to trays in which no embryos hatched.

```{r}

# IN SECONDS, Anova
aov1 <- aov(Con1_600 ~ Age.day*Stimulus, data=data2018) ##create this column
summary(aov1)

# IN SECONDS, GLM METHOD
glmm1<-glmer(Con1_600~Age.day+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm2<-glmer(Con1_600~Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm3<-glmer(Con1_600~Age.day+Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm4<-glmer(Con1_600~Age.day*Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)

glmms<-list(glmm1, glmm2, glmm3, glmm4)
#aictab(glms)

Anova(glmm4)
```

> If we assign a latency of 600 s to trays in which no embryos hatched, age and stimulus effects remain strong and the interaction effect is much weaker (latency in seconds: age, F1,75 = 27.98, P < 0.0001; stimulus, F2,75 = 7.77, P = 0.0009; interaction F2,75 = 0.75, P = 0.47). 

### MEAN Latency of ALL eggs, not just the first to hatch

```{r}
min(data2018$MeanLtoH, na.rm=T)
max(data2018$MeanLtoH, na.rm=T)
```
> For all embryos that hatched within a 5 minute stimulus duration, the mean latency to hatch ranged from 15 to 240 s. 

Are our data parametric?

```{r}
hist(data2018$MeanLtoH) 
hist(log(data2018$MeanLtoH)) #parametric enough!
```
Since they are, we can use ANOVAs of log-transformed data to test for 
effects of age, stimulus and age-by-stimulus interaction 
on the latency to hatch. 

```{r}
# IN SECONDS, Anova
aov1 <- aov(log(MeanLtoH) ~ Age.day*Stimulus, data=data2018)
summary(aov1)
```
> Latency did not vary among stimuli but decreased with age, with a non-significant interaction effect (Fig. 6B,C) (age, F1,114 = 33.737, P = 5.81e-8; stimulus, F2,114 = 1.668, P = 0.193; interaction, F2,114 = 1.792, P = 0.171).

Alternatively, we can use GLMs: 

```{r}
# IN SECONDS, GLM METHOD
glmm1<-glmer(MeanLtoH~Age.day+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm2<-glmer(MeanLtoH~Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm3<-glmer(MeanLtoH~Age.day+Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm4<-glmer(MeanLtoH~Age.day*Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)

glmms<-list(glmm1, glmm2, glmm3, glmm4)
#aictab(glms)

Anova(glmm4)
```

Here we plot the latencies for the first embryo in each tray to hatch: 

```{r}
LtoH_younger_errorstats2018<-
  younger2018 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(MeanLtoH, na.rm=T),
            SD = sd(MeanLtoH, na.rm=T), 
            SE = sd(MeanLtoH, na.rm=T)/sqrt(n())
            )
LtoH_younger_errorstats2018$AgeGroup <- "4"
kable(LtoH_younger_errorstats2018,title="Mean & SD & SE",digits=3)

LtoH_older_errorstats2018<-
  older2018 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(MeanLtoH, na.rm=T),
            SD = sd(MeanLtoH, na.rm=T), 
            SE = sd(MeanLtoH, na.rm=T)/sqrt(n())
            )
LtoH_older_errorstats2018$AgeGroup <- "5"
kable(LtoH_older_errorstats2018,title="Mean & SD & SE",digits=3)
```

Now we can make the plot! 

```{r}
LtoH_combined_errorstats2018<- rbind(LtoH_younger_errorstats2018, LtoH_older_errorstats2018)
```

The following code creates our figure (for the mean latency to hatch of the eggs that hatching per tray)
```{r}
ggplot(data=LtoH_combined_errorstats2018, aes(x=Age.day, y=mean, colour=Stimulus)) + 
  geom_point(size=3) +
  geom_errorbar(data=LtoH_combined_errorstats2018, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  theme_bw(20)+
  ylab("Latency to hatch (seconds)\n")+
  xlab("\n Age (d)")
```


```{r}
mean(mt_older$MeanLtoH, na.rm=T)
se(mt_older$MeanLtoH, na.rm=T)
```

> The shortest latency times were for the LF stimulus (younger: 39.5 ± 10.1 s; older 18.6 ± 1.9 s), 
 while latencies for the LS stimulus included the fewest cycles of the vibration pattern 
(younger: 6.5 ± 1.6; older: 1.9 ± 0.3 cycles). 

### MEDIAN Latency of ALL eggs, not just the first to hatch

```{r}
min(data2018$MedianLtoH, na.rm=T)
max(data2018$MedianLtoH, na.rm=T)
```
> For all embryos that hatched within a 5 minute stimulus duration, the median latency to hatch ranged from 15 to 240 s. 

Are our data parametric?

```{r}
hist(data2018$MedianLtoH) 
hist(data2018(data$MedianLtoH)) #parametric enough!
```

Since they are, we can use ANOVAs of log-transformed data to test for 
effects of age, stimulus and age-by-stimulus interaction 
on the latency to hatch. 

```{r}
# IN SECONDS, Anova
aov1 <- aov(log(MedianLtoH) ~ Age.day*Stimulus, data=data2018)
summary(aov1)
```

> Latency did not vary among stimuli but decreased with age, with a non-significant interaction effect (Fig. 6B,C) (age, F1,114 = 33.737, P = 5.81e-8; stimulus, F2,114 = 1.668, P = 0.193; interaction, F2,114 = 1.792, P = 0.171).

Alternatively, we can use GLMs: 

```{r}
# IN SECONDS, GLM METHOD
glmm1<-glmer(MedianLtoH~Age.day+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm2<-glmer(MedianLtoH~Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm3<-glmer(MedianLtoH~Age.day+Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm4<-glmer(MedianLtoH~Age.day*Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)

glmms<-list(glmm1, glmm2, glmm3, glmm4)
#aictab(glms)

Anova(glmm4)
```

Here we plot the latencies for the first embryo in each tray to hatch: 

```{r}
LtoH_younger_errorstats2018<-
  younger2018 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(MedianLtoH, na.rm=T),
            SD = sd(MedianLtoH, na.rm=T), 
            SE = sd(MedianLtoH, na.rm=T)/sqrt(n())
            )
LtoH_younger_errorstats2018$AgeGroup <- "4"
kable(LtoH_younger_errorstats2018,title="Mean & SD & SE",digits=3)

LtoH_older_errorstats2018<-
  older %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(MedianLtoH, na.rm=T),
            SD = sd(MedianLtoH, na.rm=T), 
            SE = sd(MedianLtoH, na.rm=T)/sqrt(n())
            )
LtoH_older_errorstats2018$AgeGroup <- "5"
kable(LtoH_older_errorstats2018,title="Mean & SD & SE",digits=3)
```

Now we can make the plot! 

```{r}
LtoH_combined_errorstats2018<- rbind(LtoH_younger_errorstats2018, LtoH_older_errorstats2018)
```

The following code creates our figure (for the mean latency to hatch of the eggs that hatching per tray)
```{r}
ggplot(data=LtoH_combined_errorstats2018, aes(x=AgeGroup, y=mean, colour=Stimulus)) + 
  geom_point(size=3) +
  geom_errorbar(data=LtoH_combined_errorstats2018, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  theme_bw(20)+
  ylab("Latency to hatch (seconds)\n")+
  xlab("\n Age (d)")
```

```{r}
mean(mt_older$MedianLtoH, na.rm=T)
se(mt_older$MedianLtoH, na.rm=T)
```
> The shortest latency times were for the LF stimulus (younger: 39.5 ± 10.1 s; older 18.6 ± 1.9 s), 
 while latencies for the LS stimulus included the fewest cycles of the vibration pattern 
(younger: 6.5 ± 1.6; older: 1.9 ± 0.3 cycles). 

### RANGE Latency of ALL eggs, not just the first to hatch

```{r}
min(data2018$RangeLtoH, na.rm=T)
max(data2018$RangeLtoH, na.rm=T)
```
> For all embryos that hatched within a 5 minute stimulus duration, the range for latencies to hatch in the tray ranged from 0 to 283 s. 

Are our data parametric?

```{r}
hist(data2018$RangeLtoH) 
hist(log(data2018$RangeLtoH)) #not parametric
```

Since they are, we can use ANOVAs of log-transformed data to test for 
effects of age, stimulus and age-by-stimulus interaction 
on the latency to hatch. 

```{r}
# IN SECONDS, Anova
aov1 <- aov(log(RangeLtoH) ~ Age.day*Stimulus, data=data2018)
summary(aov1)
```

> Latency did not vary among stimuli but decreased with age, with a non-significant interaction effect (Fig. 6B,C) (age, F1,114 = 33.737, P = 5.81e-8; stimulus, F2,114 = 1.668, P = 0.193; interaction, F2,114 = 1.792, P = 0.171).

Alternatively, we can use GLMs: 

```{r}
# IN SECONDS, GLM METHOD
glmm1<-glmer(RangeLtoH~Age.day+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm2<-glmer(RangeLtoH~Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm3<-glmer(RangeLtoH~Age.day+Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)
glmm4<-glmer(RangeLtoH~Age.day*Stimulus+ (1|Clutch), family=gaussian(link = "identity"), data=data2018)

glmms<-list(glmm1, glmm2, glmm3, glmm4)
#aictab(glms)

Anova(glmm4)
```

Here we plot the latencies for the first embryo in each tray to hatch: 

```{r}
LtoH_younger_errorstats2018<-
  younger2018 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(RangeLtoH, na.rm=T),
            SD = sd(RangeLtoH, na.rm=T), 
            SE = sd(RangeLtoH, na.rm=T)/sqrt(n())
            )
LtoH_younger_errorstats2018$AgeGroup <- "5"
kable(LtoH_younger_errorstats2018,title="Mean & SD & SE",digits=3)

LtoH_older_errorstats2018<-
  older2018 %>%
  group_by(Stimulus) %>%
  summarize(count = n(),
            mean = mean(RangeLtoH, na.rm=T),
            SD = sd(RangeLtoH, na.rm=T), 
            SE = sd(RangeLtoH, na.rm=T)/sqrt(n())
            )
LtoH_older_errorstats2018$AgeGroup <- "6"
kable(LtoH_older_errorstats2018,title="Mean & SD & SE",digits=3)
```

Now we can make the plot! 

```{r}
LtoH_combined_errorstats2018<- rbind(LtoH_younger_errorstats2018, LtoH_older_errorstats2018)
```

The following code creates our figure (for the mean latency to hatch of the eggs that hatching per tray)
```{r}
ggplot(data=LtoH_combined_errorstats2018, aes(x=Age.day, y=mean, colour=Stimulus)) + 
  geom_point(size=3) +
  geom_errorbar(data=LtoH_combined_errorstats2018, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  theme_bw(20)+
  ylab("Range of Latencies (seconds)\n")+
  xlab("\n Age (d)")
```


```{r}
mean(mt_older$RangeLtoH, na.rm=T)
se(mt_older$RangeLtoH, na.rm=T)
```
> The shortest latency times were for the LF stimulus (younger: 39.5 ± 10.1 s; older 18.6 ± 1.9 s), 
 while latencies for the LS stimulus included the fewest cycles of the vibration pattern 
(younger: 6.5 ± 1.6; older: 1.9 ± 0.3 cycles). 

# TacAttack

Next, we want to read in the relevant datafile and show a few lines of raw data in your output (e.g., using head()).

```{r}
tacattack <- read.csv(file="TacAttack_v1.csv")
head(tacattack)
```

Now let's look at the structure of our data, and make sure the variables are defined as we want them to be defined. 

```{r, warning=FALSE}
str(tacattack)
#data$ProportionHatched<-as.numeric(as.character(data$ProportionHatched))
#data$Date<-as.factor(data$Date)
```

Here let's subset the data into 2 age groups: younger and older. 

```{r, warning=FALSE}
younger<-subset(tacattack, Age==4, na.rm=T)
older<-subset(tacattack, Age==5, na.rm=T)
```

## Proportion Hatched
Summarize the data

Here we'll create a table summary of statistics for hatching rates (in proportion hatched) for each age category, grouped by stimulus treatment. We use the {dplyr} package to summarize our data. 

```{r}
younger_tacattack<-
  younger %>%
  group_by(Location) %>%
  summarize(count = n(),
            mean = mean(Hatch.Time..seconds.),
            SD = sd(Hatch.Time..seconds.), 
            SE = sd(Hatch.Time..seconds.)/sqrt(n())
            )
younger_tacattack$AgeGroup <- 4
kable(younger_tacattack,title="Mean & SD & SE",digits=3)

older_tacattack<-
  older %>%
  group_by(Location) %>%
  summarize(count = n(),
            mean = mean(Hatch.Time..seconds.),
            SD = sd(Hatch.Time..seconds.), 
            SE = sd(Hatch.Time..seconds.)/sqrt(n())
            )
older_tacattack$AgeGroup <- 5
kable(older_tacattack,title="Mean & SD & SE",digits=3)
```

We can use ggplot to create a much prettier plot, with standard errors. 

```{r}
younger_tacattack$AgeGroup<-as.factor(younger_tacattack$AgeGroup)
older_tacattack$AgeGroup<-as.factor(older_tacattack$AgeGroup)
combined_tacattack<- rbind(younger_tacattack, older_tacattack)
```

The following code creates our figure:
```{r}
ggplot(data=combined_tacattack, aes(x=AgeGroup, y=mean, colour=Location)) + 
  geom_point(size=3) +
  geom_errorbar(data=combined_tacattack, aes(ymin=mean-SE, ymax=mean+SE), width=0.05)+
  cowplot::theme_cowplot() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  scale_y_continuous(limits = c(0, 300)) +
  ylab("Hatch Time (secs)\n")+
  xlab("\n Age (d)")
```

#### Discussion 
Older embryos showed lower latency to hatch, indicating less cue sampling, and more hatching overall. Their similarly high responses to two of the stimuli suggest they ceased to discriminate using slow-to-assess properties as indicators of safety; however, they showed little hatching if either frequency spectrum or a fast temporal pattern allowed rapid assessment of low risk. 

#### Conclusion
Developmental changes in behavior due to ontogenetic adaptation of decision processes are likely to be widespread. Vibration-cued hatching allows us to use the power of playback experiments to improve our understanding of the development of adaptive embryo behavior.